"""
Database layer for storing trading signals and performance metrics.
Uses SQLAlchemy ORM with SQLite for simplicity and portability.
"""

import logging
from datetime import datetime
from typing import Optional, List, Dict
from sqlalchemy import create_engine, Column, Float, String, DateTime, Integer, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

logger = logging.getLogger(__name__)
Base = declarative_base()


class TradeSignal(Base):
    """
    Database model for storing trading signals generated by the system.
    Each signal represents a potential trading opportunity with metadata.
    """
    __tablename__ = 'trade_signals'

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    symbol = Column(String, nullable=False)
    signal_type = Column(String, nullable=False)  # 'BUY' or 'SELL'
    entry_price = Column(Float, nullable=False)
    stop_loss_price = Column(Float, nullable=True)
    take_profit_1 = Column(Float, nullable=True)
    take_profit_2 = Column(Float, nullable=True)
    take_profit_3 = Column(Float, nullable=True)
    leverage = Column(Float, default=1.0)
    confidence_score = Column(Float, nullable=False)
    ai_confirmed = Column(Boolean, default=False)
    risk_percent = Column(Float, nullable=False)
    position_size = Column(Float, nullable=False)
    status = Column(String, default='PENDING')  # PENDING, EXECUTED, REJECTED, EVALUATED
    outcome = Column(String, nullable=True)  # WIN, LOSS, PENDING
    tp_hit = Column(String, nullable=True)  # TP1, TP2, TP3, NONE
    hit_stop_loss = Column(Boolean, default=False)
    final_price = Column(Float, nullable=True)  # Final price when evaluated
    profit_loss = Column(Float, nullable=True)  # Actual P&L in USD
    evaluation_timestamp = Column(DateTime, nullable=True)
    review_notes = Column(String, nullable=True)  # Manual review notes
    notes = Column(String, nullable=True)


class PerformanceMetrics(Base):
    """
    Tracks overall trading performance and system health.
    Aggregates statistics for risk monitoring and strategy optimization.
    """
    __tablename__ = 'performance_metrics'

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    current_balance = Column(Float, nullable=False)
    total_trades = Column(Integer, default=0)
    winning_trades = Column(Integer, default=0)
    losing_trades = Column(Integer, default=0)
    total_pnl = Column(Float, default=0.0)
    win_rate = Column(Float, default=0.0)
    avg_risk_per_trade = Column(Float, default=0.0)


class DatabaseManager:
    """
    Manages database operations for the trading bot.
    Handles connection pooling, queries, and transaction management.
    """

    def __init__(self, db_path: str = "trading_bot.db"):
        """Initialize database connection and create tables."""
        self.engine = create_engine(f'sqlite:///{db_path}', echo=False)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)

    def save_signal(self, signal_data: Dict) -> TradeSignal:
        """Save a new trading signal to database."""
        session = self.Session()
        try:
            signal = TradeSignal(**signal_data)
            session.add(signal)
            session.commit()
            session.refresh(signal)
            logger.info(f"Signal saved: {signal.symbol} {signal.signal_type} "
                       f"(confidence: {signal.confidence_score:.2f})")
            return signal
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to save signal: {e}")
            raise
        finally:
            session.close()

    def get_recent_signals(self, limit: int = 10) -> List[TradeSignal]:
        """Retrieve recent trading signals for analysis."""
        session = self.Session()
        try:
            signals = session.query(TradeSignal).order_by(
                TradeSignal.timestamp.desc()
            ).limit(limit).all()
            return signals
        finally:
            session.close()

    def update_signal_status(self, signal_id: int, status: str) -> bool:
        """Update the status of a trading signal."""
        session = self.Session()
        try:
            signal = session.query(TradeSignal).filter_by(id=signal_id).first()
            if signal:
                signal.status = status
                session.commit()
                logger.info(f"Signal {signal_id} status updated to {status}")
                return True
            return False
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to update signal status: {e}")
            return False
        finally:
            session.close()

    def get_performance_metrics(self) -> Optional[PerformanceMetrics]:
        """Get the latest performance metrics."""
        session = self.Session()
        try:
            metrics = session.query(PerformanceMetrics).order_by(
                PerformanceMetrics.timestamp.desc()
            ).first()
            return metrics
        finally:
            session.close()

    def save_performance_metrics(self, metrics_data: Dict) -> PerformanceMetrics:
        """Save or update performance metrics."""
        session = self.Session()
        try:
            metrics = PerformanceMetrics(**metrics_data)
            session.add(metrics)
            session.commit()
            session.refresh(metrics)
            return metrics
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to save metrics: {e}")
            raise
        finally:
            session.close()
    
    def get_unevaluated_signals(self) -> List[TradeSignal]:
        """Get all signals that haven't been evaluated yet."""
        session = self.Session()
        try:
            signals = session.query(TradeSignal).filter(
                TradeSignal.outcome == None
            ).all()
            return signals
        finally:
            session.close()
    
    def update_signal_outcome(self, signal_id: int, outcome_data: Dict) -> bool:
        """Update signal with evaluation results."""
        session = self.Session()
        try:
            signal = session.query(TradeSignal).filter_by(id=signal_id).first()
            if signal:
                signal.outcome = outcome_data.get('outcome')
                signal.tp_hit = outcome_data.get('tp_hit')
                signal.hit_stop_loss = outcome_data.get('hit_stop_loss', False)
                signal.final_price = outcome_data.get('final_price')
                signal.profit_loss = outcome_data.get('profit_loss')
                signal.evaluation_timestamp = datetime.utcnow()
                signal.status = 'EVALUATED'
                session.commit()
                logger.info(f"Signal {signal_id} evaluated: {outcome_data.get('outcome')}")
                return True
            return False
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to update signal outcome: {e}")
            return False
        finally:
            session.close()
    
    def get_signals_by_outcome(self, outcome: str) -> List[TradeSignal]:
        """Get signals filtered by outcome (WIN, LOSS, PENDING)."""
        session = self.Session()
        try:
            signals = session.query(TradeSignal).filter(
                TradeSignal.outcome == outcome
            ).order_by(TradeSignal.timestamp.desc()).all()
            return signals
        finally:
            session.close()
    
    def get_signals_by_date(self, date: datetime) -> List[TradeSignal]:
        """Get all signals generated on a specific date."""
        session = self.Session()
        try:
            start = date.replace(hour=0, minute=0, second=0)
            end = date.replace(hour=23, minute=59, second=59)
            signals = session.query(TradeSignal).filter(
                TradeSignal.timestamp >= start,
                TradeSignal.timestamp <= end
            ).all()
            return signals
        finally:
            session.close()

