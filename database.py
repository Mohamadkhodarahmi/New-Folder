"""
Database layer for storing trading signals and performance metrics.
Uses SQLAlchemy ORM with SQLite for simplicity and portability.
"""

import logging
from datetime import datetime
from typing import Optional, List, Dict
from sqlalchemy import create_engine, Column, Float, String, DateTime, Integer, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

logger = logging.getLogger(__name__)
Base = declarative_base()


class TradeSignal(Base):
    """
    Database model for storing trading signals generated by the system.
    Each signal represents a potential trading opportunity with metadata.
    """
    __tablename__ = 'trade_signals'

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    symbol = Column(String, nullable=False)
    signal_type = Column(String, nullable=False)  # 'BUY' or 'SELL'
    entry_price = Column(Float, nullable=False)
    stop_loss_price = Column(Float, nullable=True)
    take_profit_1 = Column(Float, nullable=True)
    take_profit_2 = Column(Float, nullable=True)
    take_profit_3 = Column(Float, nullable=True)
    leverage = Column(Float, default=1.0)
    confidence_score = Column(Float, nullable=False)
    ai_confirmed = Column(Boolean, default=False)
    risk_percent = Column(Float, nullable=False)
    position_size = Column(Float, nullable=False)
    status = Column(String, default='PENDING')  # PENDING, EXECUTED, REJECTED
    notes = Column(String, nullable=True)


class PerformanceMetrics(Base):
    """
    Tracks overall trading performance and system health.
    Aggregates statistics for risk monitoring and strategy optimization.
    """
    __tablename__ = 'performance_metrics'

    id = Column(Integer, primary_key=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    current_balance = Column(Float, nullable=False)
    total_trades = Column(Integer, default=0)
    winning_trades = Column(Integer, default=0)
    losing_trades = Column(Integer, default=0)
    total_pnl = Column(Float, default=0.0)
    win_rate = Column(Float, default=0.0)
    avg_risk_per_trade = Column(Float, default=0.0)


class DatabaseManager:
    """
    Manages database operations for the trading bot.
    Handles connection pooling, queries, and transaction management.
    """

    def __init__(self, db_path: str = "trading_bot.db"):
        """Initialize database connection and create tables."""
        self.engine = create_engine(f'sqlite:///{db_path}', echo=False)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)

    def save_signal(self, signal_data: Dict) -> TradeSignal:
        """Save a new trading signal to database."""
        session = self.Session()
        try:
            signal = TradeSignal(**signal_data)
            session.add(signal)
            session.commit()
            session.refresh(signal)
            logger.info(f"Signal saved: {signal.symbol} {signal.signal_type} "
                       f"(confidence: {signal.confidence_score:.2f})")
            return signal
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to save signal: {e}")
            raise
        finally:
            session.close()

    def get_recent_signals(self, limit: int = 10) -> List[TradeSignal]:
        """Retrieve recent trading signals for analysis."""
        session = self.Session()
        try:
            signals = session.query(TradeSignal).order_by(
                TradeSignal.timestamp.desc()
            ).limit(limit).all()
            return signals
        finally:
            session.close()

    def update_signal_status(self, signal_id: int, status: str) -> bool:
        """Update the status of a trading signal."""
        session = self.Session()
        try:
            signal = session.query(TradeSignal).filter_by(id=signal_id).first()
            if signal:
                signal.status = status
                session.commit()
                logger.info(f"Signal {signal_id} status updated to {status}")
                return True
            return False
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to update signal status: {e}")
            return False
        finally:
            session.close()

    def get_performance_metrics(self) -> Optional[PerformanceMetrics]:
        """Get the latest performance metrics."""
        session = self.Session()
        try:
            metrics = session.query(PerformanceMetrics).order_by(
                PerformanceMetrics.timestamp.desc()
            ).first()
            return metrics
        finally:
            session.close()

    def save_performance_metrics(self, metrics_data: Dict) -> PerformanceMetrics:
        """Save or update performance metrics."""
        session = self.Session()
        try:
            metrics = PerformanceMetrics(**metrics_data)
            session.add(metrics)
            session.commit()
            session.refresh(metrics)
            return metrics
        except Exception as e:
            session.rollback()
            logger.error(f"Failed to save metrics: {e}")
            raise
        finally:
            session.close()

